using Microsoft.Extensions.DependencyInjection;
using Vitraux.Execution.JsInvokers.Actions.Registration;
using Vitraux.Execution.ViewModelNames.Actions;
using Vitraux.Helpers;
using Vitraux.JsCodeGeneration.Actions;
using Vitraux.JsCodeGeneration.JsObjectNames;
using Vitraux.Modeling.Data.Actions;

namespace Vitraux.Execution.Building;

internal class ViewModelActionsBuilder<TViewModel>(
    IJsActionElementObjectNamesGenerator jsActionElementObjectNamesGenerator,
    IRootActionsJsGenerator rootActionsJsGenerator,
    IJsTryInitializeActionsFunctionFromCacheByVersionInvoker tryInitializeFromCacheByVersionInvoker,
    IJsInitializeNewActionsFunctionToCacheByVersionInvoker initializeNewToCacheByVersionInvoker,
    IJsInitializeNonCachedActionsFunctionInvoker initializeNonCachedInvoker,
    IViewModelJsActionsRepository viewModelJsActionsRepository,
    IViewModelRepository viewModelRepository,
    IServiceProvider serviceProvider,
    INotImplementedCaseGuard notImplementedCaseGuard) : IViewModelActionsBuilder<TViewModel> where TViewModel : class
{
    public Task Build(string vmKey, ConfigurationBehavior configurationBehavior, IEnumerable<ActionData> actions)
    {
        switch (configurationBehavior.AutoGeneratedFunctionCaching)
        {
            case AutoGeneratedFunctionNoCache:
                InvokeInitializationNonCache(vmKey, configurationBehavior.QueryElementStrategy, configurationBehavior.ActionRegistrationStrategy, actions);
                break;

            case AutoGeneratedFunctionCacheByVersion cacheByVersion:
                InvokeInitializationByVersion(vmKey, cacheByVersion.Version, configurationBehavior.QueryElementStrategy, configurationBehavior.ActionRegistrationStrategy, actions);
                break;

            default:
                notImplementedCaseGuard.ThrowException(configurationBehavior.AutoGeneratedFunctionCaching);
                break;
        }

        AddViewModelActionsToRepository(vmKey, actions);
        TryStoreViewModelSingletonInstance(vmKey);

        return Task.CompletedTask;
    }

    private void AddViewModelActionsToRepository(string vmKey, IEnumerable<ActionData> actions)
        => viewModelJsActionsRepository.AddViewModelActions(vmKey, ConvertToActionInfos(actions));

    private void TryStoreViewModelSingletonInstance(string vmKey)
    {
        var vm = serviceProvider.GetService<TViewModel>();

        if (vm is not null)
            viewModelRepository.SetViewModelInstance(vmKey, vm);
    }

    private static IEnumerable<ViewModelJsActionInfo> ConvertToActionInfos(IEnumerable<ActionData> actions)
        => actions.Select(a => new ViewModelJsActionInfo(a.ActionKey, a.Invokable, a.PassInputValueParameter, a.Parameters.Select(p => p.ParamName)));

    private string GenerateJsCode(string vmKey, QueryElementStrategy queryElementStrategy, IEnumerable<ActionData> actions)
    {
        var jsNames = jsActionElementObjectNamesGenerator.Generate(string.Empty, actions);
        return rootActionsJsGenerator.GenerateJs(vmKey, actions, jsNames, queryElementStrategy);
    }

    private void InvokeInitializationByVersion(string vmKey, string version, QueryElementStrategy queryElementStrategy, ActionRegistrationStrategy actionRegistrationStrategy, IEnumerable<ActionData> actions)
    {
        if (!tryInitializeFromCacheByVersionInvoker.Invoke(vmKey, version))
        {
            var generatedJsCode = GenerateJsCode(vmKey, queryElementStrategy, actions);
            initializeNewToCacheByVersionInvoker.Invoke(vmKey, version, generatedJsCode, actionRegistrationStrategy);
        }
    }

    private void InvokeInitializationNonCache(string vmKey, QueryElementStrategy queryElementStrategy, ActionRegistrationStrategy actionRegistrationStrategy, IEnumerable<ActionData> actions)
    {
        var generatedJsCode = GenerateJsCode(vmKey, queryElementStrategy, actions);
        initializeNonCachedInvoker.Invoke(vmKey, generatedJsCode, actionRegistrationStrategy);
    }
}